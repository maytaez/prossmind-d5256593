/**
 * BPMN JSON Schema
 * 
 * This defines a simplified JSON structure for BPMN processes that can be
 * easily generated by AI models and converted to BPMN 2.0 XML.
 */

export type BPMNElementType =
    | 'startEvent'
    | 'endEvent'
    | 'task'
    | 'userTask'
    | 'serviceTask'
    | 'scriptTask'
    | 'businessRuleTask'
    | 'manualTask'
    | 'sendTask'
    | 'receiveTask'
    | 'exclusiveGateway'
    | 'parallelGateway'
    | 'inclusiveGateway'
    | 'eventBasedGateway'
    | 'subprocess'
    | 'intermediateThrowEvent'
    | 'intermediateCatchEvent'
    | 'boundaryEvent';

export interface BPMNElement {
    id: string;
    type: BPMNElementType;
    name: string;

    // For gateways
    gatewayDirection?: 'Diverging' | 'Converging' | 'Mixed';

    // For events
    eventDefinitionType?: 'message' | 'timer' | 'error' | 'escalation' | 'signal' | 'conditional' | 'link' | 'compensation';

    // For subprocesses - contains nested elements
    elements?: BPMNElement[];
    flows?: BPMNSequenceFlow[];

    // For boundary events
    attachedToRef?: string;
    cancelActivity?: boolean;

    // Optional metadata
    documentation?: string;
    properties?: Record<string, string>;
}

export interface BPMNSequenceFlow {
    id: string;
    name?: string;
    sourceRef: string;
    targetRef: string;

    // For conditional flows
    conditionExpression?: string;

    // For default flows from gateways
    isDefault?: boolean;
}

export interface BPMNProcess {
    id: string;
    name: string;
    isExecutable?: boolean;
    elements: BPMNElement[];
    flows: BPMNSequenceFlow[];
    documentation?: string;
}

export interface BPMNDefinitions {
    id: string;
    name?: string;
    targetNamespace?: string;
    processes: BPMNProcess[];
}

/**
 * Validation functions
 */

export interface ValidationError {
    field: string;
    message: string;
    elementId?: string;
}

export interface ValidationResult {
    valid: boolean;
    errors: ValidationError[];
}

export function validateBPMNElement(element: BPMNElement, path: string = ''): ValidationError[] {
    const errors: ValidationError[] = [];
    const currentPath = path ? `${path}.${element.id}` : element.id;

    if (!element.id) {
        errors.push({ field: `${currentPath}.id`, message: 'Element ID is required' });
    }

    if (!element.type) {
        errors.push({ field: `${currentPath}.type`, message: 'Element type is required' });
    }

    if (!element.name) {
        errors.push({ field: `${currentPath}.name`, message: 'Element name is required' });
    }

    // Validate subprocess structure
    if (element.type === 'subprocess') {
        if (!element.elements || element.elements.length === 0) {
            errors.push({
                field: `${currentPath}.elements`,
                message: 'Subprocess must contain at least one element',
                elementId: element.id
            });
        }

        if (!element.flows) {
            errors.push({
                field: `${currentPath}.flows`,
                message: 'Subprocess must have flows array',
                elementId: element.id
            });
        }

        // Recursively validate subprocess elements
        if (element.elements) {
            element.elements.forEach(subElement => {
                errors.push(...validateBPMNElement(subElement, currentPath));
            });
        }
    }

    // Validate boundary events
    if (element.type === 'boundaryEvent') {
        if (!element.attachedToRef) {
            errors.push({
                field: `${currentPath}.attachedToRef`,
                message: 'Boundary event must reference an activity',
                elementId: element.id
            });
        }
    }

    return errors;
}

export function validateBPMNSequenceFlow(flow: BPMNSequenceFlow, elements: BPMNElement[]): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!flow.id) {
        errors.push({ field: 'flow.id', message: 'Flow ID is required' });
    }

    if (!flow.sourceRef) {
        errors.push({ field: `${flow.id}.sourceRef`, message: 'Flow source reference is required' });
    }

    if (!flow.targetRef) {
        errors.push({ field: `${flow.id}.targetRef`, message: 'Flow target reference is required' });
    }

    // Check if referenced elements exist
    const elementIds = new Set(elements.map(e => e.id));

    if (flow.sourceRef && !elementIds.has(flow.sourceRef)) {
        errors.push({
            field: `${flow.id}.sourceRef`,
            message: `Source element '${flow.sourceRef}' not found`
        });
    }

    if (flow.targetRef && !elementIds.has(flow.targetRef)) {
        errors.push({
            field: `${flow.id}.targetRef`,
            message: `Target element '${flow.targetRef}' not found`
        });
    }

    return errors;
}

export function validateBPMNProcess(process: BPMNProcess): ValidationResult {
    const errors: ValidationError[] = [];

    if (!process.id) {
        errors.push({ field: 'process.id', message: 'Process ID is required' });
    }

    if (!process.name) {
        errors.push({ field: 'process.name', message: 'Process name is required' });
    }

    if (!process.elements || process.elements.length === 0) {
        errors.push({ field: 'process.elements', message: 'Process must contain at least one element' });
    }

    // Validate all elements
    if (process.elements) {
        process.elements.forEach(element => {
            errors.push(...validateBPMNElement(element));
        });
    }

    // Validate all flows
    if (process.flows) {
        process.flows.forEach(flow => {
            errors.push(...validateBPMNSequenceFlow(flow, process.elements));
        });
    }

    // Check for duplicate IDs
    const allIds = new Set<string>();
    const duplicates = new Set<string>();

    const checkDuplicateIds = (elements: BPMNElement[]) => {
        elements.forEach(element => {
            if (allIds.has(element.id)) {
                duplicates.add(element.id);
            }
            allIds.add(element.id);

            if (element.elements) {
                checkDuplicateIds(element.elements);
            }
        });
    };

    if (process.elements) {
        checkDuplicateIds(process.elements);
    }

    if (process.flows) {
        process.flows.forEach(flow => {
            if (allIds.has(flow.id)) {
                duplicates.add(flow.id);
            }
            allIds.add(flow.id);
        });
    }

    duplicates.forEach(id => {
        errors.push({ field: 'id', message: `Duplicate ID found: ${id}`, elementId: id });
    });

    return {
        valid: errors.length === 0,
        errors
    };
}

export function validateBPMNDefinitions(definitions: BPMNDefinitions): ValidationResult {
    const errors: ValidationError[] = [];

    if (!definitions.id) {
        errors.push({ field: 'definitions.id', message: 'Definitions ID is required' });
    }

    if (!definitions.processes || definitions.processes.length === 0) {
        errors.push({ field: 'definitions.processes', message: 'At least one process is required' });
    }

    // Validate all processes
    if (definitions.processes) {
        definitions.processes.forEach(process => {
            const processValidation = validateBPMNProcess(process);
            errors.push(...processValidation.errors);
        });
    }

    return {
        valid: errors.length === 0,
        errors
    };
}

/**
 * Helper functions to create BPMN elements
 */

export function createStartEvent(id: string, name: string = 'Start'): BPMNElement {
    return { id, type: 'startEvent', name };
}

export function createEndEvent(id: string, name: string = 'End'): BPMNElement {
    return { id, type: 'endEvent', name };
}

export function createTask(id: string, name: string): BPMNElement {
    return { id, type: 'task', name };
}

export function createUserTask(id: string, name: string): BPMNElement {
    return { id, type: 'userTask', name };
}

export function createExclusiveGateway(id: string, name: string = ''): BPMNElement {
    return { id, type: 'exclusiveGateway', name };
}

export function createParallelGateway(id: string, name: string = ''): BPMNElement {
    return { id, type: 'parallelGateway', name };
}

export function createSubprocess(
    id: string,
    name: string,
    elements: BPMNElement[],
    flows: BPMNSequenceFlow[]
): BPMNElement {
    return { id, type: 'subprocess', name, elements, flows };
}

export function createSequenceFlow(
    id: string,
    sourceRef: string,
    targetRef: string,
    name?: string
): BPMNSequenceFlow {
    return { id, sourceRef, targetRef, name };
}

export function createProcess(
    id: string,
    name: string,
    elements: BPMNElement[],
    flows: BPMNSequenceFlow[]
): BPMNProcess {
    return { id, name, isExecutable: false, elements, flows };
}

export function createDefinitions(
    id: string,
    processes: BPMNProcess[],
    name?: string
): BPMNDefinitions {
    return {
        id,
        name,
        targetNamespace: 'http://bpmn.io/schema/bpmn',
        processes
    };
}
